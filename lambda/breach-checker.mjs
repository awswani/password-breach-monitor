import { DynamoDBClient, PutItemCommand, QueryCommand } from "@aws-sdk/client-dynamodb";
import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
import https from 'https';

const dynamodb = new DynamoDBClient({ region: process.env.AWS_REGION });
const sns = new SNSClient({ region: process.env.AWS_REGION });

const HIBP_API_URL = 'https://haveibeenpwned.com/api/v3';
const MONITORED_EMAILS = (process.env.MONITORED_EMAILS || '').split(',');
const SNS_TOPIC_ARN = process.env.SNS_TOPIC_ARN;
const TABLE_NAME = process.env.TABLE_NAME;

/**
 * Check if email has been in any breaches using HaveIBeenPwned API
 */
async function checkBreaches(email) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'haveibeenpwned.com',
            path: `/api/v3/breachedaccount/${encodeURIComponent(email)}?truncateResponse=false`,
            method: 'GET',
            headers: {
                'User-Agent': 'Password-Breach-Monitor',
                'hibp-api-key': process.env.HIBP_API_KEY // Get free key from haveibeenpwned.com
            }
        };

        const req = https.request(options, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                if (res.statusCode === 200) {
                    resolve(JSON.parse(data));
                } else if (res.statusCode === 404) {
                    resolve([]); // No breaches found
                } else {
                    reject(new Error(`API returned status ${res.statusCode}: ${data}`));
                }
            });
        });

        req.on('error', reject);
        req.end();
    });
}

/**
 * Check if breach has been reported before
 */
async function isNewBreach(email, breachName) {
    const params = {
        TableName: TABLE_NAME,
        KeyConditionExpression: 'email = :email AND breachName = :breachName',
        ExpressionAttributeValues: {
            ':email': { S: email },
            ':breachName': { S: breachName }
        }
    };

    const result = await dynamodb.send(new QueryCommand(params));
    return result.Items.length === 0;
}

/**
 * Store breach in DynamoDB
 */
async function storeBreach(email, breach) {
    const params = {
        TableName: TABLE_NAME,
        Item: {
            email: { S: email },
            breachName: { S: breach.Name },
            breachDate: { S: breach.BreachDate },
            addedDate: { S: breach.AddedDate },
            pwnCount: { N: breach.PwnCount.toString() },
            description: { S: breach.Description },
            discoveredAt: { S: new Date().toISOString() }
        }
    };

    await dynamodb.send(new PutItemCommand(params));
}

/**
 * Send SNS alert for breach
 */
async function sendAlert(email, breach) {
    const message = `
🚨 PASSWORD BREACH ALERT 🚨

Email Address: ${email}
Breach: ${breach.Name}
Breach Date: ${breach.BreachDate}
Compromised Accounts: ${breach.PwnCount.toLocaleString()}

Description:
${breach.Description.replace(/<[^>]*>/g, '')} // Remove HTML tags

Compromised Data:
${breach.DataClasses.join(', ')}

⚠️ IMMEDIATE ACTIONS REQUIRED:
1. Change your password IMMEDIATELY if you still use it
2. Enable two-factor authentication (2FA)
3. Check for unauthorized account activity
4. Update passwords on any sites using the same credentials
5. Consider using a password manager

More Info: https://haveibeenpwned.com/

---
This alert was generated by your Password Breach Monitor
Detected at: ${new Date().toISOString()}
`.trim();

    const params = {
        TopicArn: SNS_TOPIC_ARN,
        Subject: `🚨 BREACH ALERT: ${email} - ${breach.Name}`,
        Message: message
    };

    await sns.send(new PublishCommand(params));
}

/**
 * Lambda handler
 */
export const handler = async (event) => {
    console.log('Starting breach check for monitored emails:', MONITORED_EMAILS);

    const results = {
        checked: 0,
        newBreaches: 0,
        errors: []
    };

    for (const email of MONITORED_EMAILS) {
        if (!email.trim()) continue;

        try {
            console.log(`Checking breaches for: ${email}`);
            const breaches = await checkBreaches(email.trim());
            results.checked++;

            console.log(`Found ${breaches.length} total breaches for ${email}`);

            for (const breach of breaches) {
                const isNew = await isNewBreach(email, breach.Name);

                if (isNew) {
                    console.log(`New breach detected: ${breach.Name}`);
                    await storeBreach(email, breach);
                    await sendAlert(email, breach);
                    results.newBreaches++;
                } else {
                    console.log(`Breach already reported: ${breach.Name}`);
                }
            }

        } catch (error) {
            console.error(`Error checking ${email}:`, error);
            results.errors.push({ email, error: error.message });
        }
    }

    console.log('Breach check complete:', results);

    return {
        statusCode: 200,
        body: JSON.stringify(results)
    };
};
